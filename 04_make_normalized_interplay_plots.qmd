---
title: "04_make_normalized_interplay_plots"
date: 02/13/2024
date-format: YYYY-MM-DD
author: Karl F Poncha
output: html
execute:
  echo: false
---

```{python}
import os
import pandas as pd
import numpy as np
import re

# Determine the base directory dynamically from the current working directory
base_dir = os.getcwd()

# Paths relative to the current working directory
input_dir = os.path.join(base_dir, "output", "interplay_scores")
output_dir = os.path.join(base_dir, "output", "interplay_scores", "interplay_matrices")

# Create the output directory if it doesn't exist
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Helper function to extract numeric position from PTM identifiers
def extract_position(ptm_id):
    # Use regular expression to find numbers between a capital letter and lowercase letters
    match = re.search(r'([A-Z])(\d+)([a-z])', ptm_id)
    if match:
        return int(match.group(2))  # Return the numeric part as an integer
    return None  # Return None if no matching pattern is found

# Function to process each CSV file
def process_csv(file_path):
    # Load the data
    data = pd.read_csv(file_path)
    
    # Define the set of all PTM modifications as both rows and columns
    ptms = set(data['PTM_1']).union(set(data['PTM_2']))
    sorted_ptms = sorted(ptms, key=extract_position)  # Sort PTMs by position
    
    # Create the pivot table with the same PTMs on both axes
    matrix = data.pivot_table(index='PTM_1', columns='PTM_2', values='normalized_interplay', aggfunc='mean').reindex(index=sorted_ptms, columns=sorted_ptms)

    # Fill missing values with NaN
    matrix_filled = matrix.fillna(np.nan)
    
    # Define the output file path
    file_name = os.path.basename(file_path)
    output_file_path = os.path.join(output_dir, file_name.replace('_interplay_scores.csv', '_interplay_matrix.csv'))
    
    # Save the matrix to a new CSV file
    matrix_filled.to_csv(output_file_path)

# Process each file in the directory
for file in os.listdir(input_dir):
    if file.endswith("_interplay_scores.csv"):
        file_path = os.path.join(input_dir, file)
        process_csv(file_path)
        print(f"Processed and saved matrix for {file}")

print("All interplay files processed successfully.")

```

```{python}
import os
import pandas as pd
import numpy as np
import re

# Determine the base directory dynamically from the current working directory
base_dir = os.getcwd()

# Paths relative to the current working directory
input_dir = os.path.join(base_dir, "output", "interplay_scores", "averaged_interplay_scores")
output_dir = os.path.join(base_dir, "output", "interplay_scores", "interplay_matrices", "averaged_interplay_matrices")

# Create the output directory if it doesn't exist
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Helper function to extract numeric position from PTM identifiers
def extract_position(ptm_id):
    # Use regular expression to find numbers between a capital letter and lowercase letters
    match = re.search(r'([A-Z])(\d+)([a-z])', ptm_id)
    if match:
        return int(match.group(2))  # Return the numeric part as an integer
    return None  # Return None if no matching pattern is found

# Function to process each CSV file
def process_csv(file_path):
    # Load the data
    data = pd.read_csv(file_path)
    
    # Define the set of all PTM modifications as both rows and columns
    ptms = set(data['PTM_1']).union(set(data['PTM_2']))
    sorted_ptms = sorted(ptms, key=extract_position)  # Sort PTMs by position
    
    # Create the pivot table with the same PTMs on both axes
    matrix = data.pivot_table(index='PTM_1', columns='PTM_2', values='avg_normalized_interplay', aggfunc='mean').reindex(index=sorted_ptms, columns=sorted_ptms)

    # Fill missing values with NaN
    matrix_filled = matrix.fillna(np.nan)
    
    # Define the output file path
    file_name = os.path.basename(file_path)
    output_file_path = os.path.join(output_dir, file_name.replace('_interplay_scores.csv', '_interplay_matrix.csv'))
    
    # Save the matrix to a new CSV file
    matrix_filled.to_csv(output_file_path)

# Process each file in the directory
for file in os.listdir(input_dir):
    if file.endswith("_avg_interplay_scores.csv"):
        file_path = os.path.join(input_dir, file)
        process_csv(file_path)
        print(f"Processed and saved matrix for {file}")

print("All averaged interplay files processed successfully.")


```